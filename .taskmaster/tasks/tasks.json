{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize NestJS Project Structure",
        "description": "Set up the foundational NestJS TypeScript project with proper directory structure, dependencies, and configuration files",
        "details": "Use NestJS CLI to generate new project with TypeScript. Install core dependencies: @nestjs/core, @nestjs/common, @nestjs/platform-express, @nestjs/typeorm, @nestjs/schedule, @nestjs/config, @nestjs/swagger, typeorm, sqlite3, reflect-metadata, rxjs. Create src/main.ts entry point, app.module.ts root module, and basic folder structure (controllers/, services/, entities/, dto/). Configure tsconfig.json and nest-cli.json. Set up package.json scripts for development and production builds.",
        "testStrategy": "Verify project compiles with 'npm run build', starts with 'npm run start', and serves on port 4000. Check that NestJS application context initializes without errors and basic health endpoint responds.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate NestJS Project with CLI",
            "description": "Use NestJS CLI to create new TypeScript project with standard scaffolding",
            "dependencies": [],
            "details": "Run 'nest new nest-crontab-gui' command to generate project structure. Select npm as package manager. Verify project structure includes src/, test/, and configuration files. Remove default controller and service files that won't be needed.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install and Configure Core Dependencies",
            "description": "Install all required NestJS and TypeORM dependencies with proper versions",
            "dependencies": [
              "1.1"
            ],
            "details": "Install @nestjs/core, @nestjs/common, @nestjs/platform-express, @nestjs/typeorm, @nestjs/schedule, @nestjs/config, @nestjs/swagger, typeorm, sqlite3, reflect-metadata, rxjs. Update package.json with development and production scripts. Configure tsconfig.json for TypeScript compilation settings.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Basic Folder Structure and Entry Points",
            "description": "Set up organized directory structure with main application files",
            "dependencies": [
              "1.2"
            ],
            "details": "Create src/controllers/, src/services/, src/entities/, src/dto/ directories. Set up src/main.ts with NestJS application bootstrap. Create app.module.ts as root module with basic imports. Add health check endpoint for application readiness verification.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Configure Build Scripts and Verify Setup",
            "description": "Set up package.json scripts and validate project compilation and startup",
            "dependencies": [
              "1.3"
            ],
            "details": "Configure nest-cli.json build settings. Add npm scripts for start, start:dev, build, test. Test project builds successfully with 'npm run build' and starts on port 4000 with 'npm run start:dev'. Verify health endpoint responds correctly.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Configure SQLite Database with TypeORM",
        "description": "Set up SQLite database connection using TypeORM with proper entity configuration and migration support",
        "details": "Configure TypeORM in app.module.ts with SQLite connection settings, database file location in ./data directory. Create database/entities directory. Implement CronJob entity with fields: id (uuid), name (string), url (string), method (GET|POST enum), headers (json), schedule (string), scheduleType (cron|repeat enum), isActive (boolean), createdAt, updatedAt. Implement ExecutionLog entity with fields: id (uuid), jobId (string), job (ManyToOne relation), executedAt (Date), status (success|error enum), responseCode (number), responseTime (number), responseBody (text), errorMessage (nullable string), triggeredManually (boolean). Enable synchronize for development, set up proper indexes.",
        "testStrategy": "Test database connection on app startup, verify entities are created in SQLite file, test basic CRUD operations on both entities using TypeORM repository methods. Verify relationships work correctly between CronJob and ExecutionLog.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure TypeORM Module and Database Connection",
            "description": "Set up TypeORM module configuration in app.module.ts with SQLite database connection and data directory setup",
            "dependencies": [],
            "details": "Configure TypeORM module in app.module.ts with SQLite driver, database file path pointing to ./data/database.sqlite. Create data directory if it doesn't exist. Set up proper development configuration with synchronize enabled. Configure entities array and autoLoadEntities option.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create CronJob Entity with Fields and Validations",
            "description": "Implement CronJob entity with all required fields, enums, and proper TypeORM decorators",
            "dependencies": [
              "2.1"
            ],
            "details": "Create database/entities/cronjob.entity.ts with fields: id (UUID primary key), name (string), url (string), method (enum GET|POST), headers (JSON type), schedule (string), scheduleType (enum cron|repeat), isActive (boolean), createdAt, updatedAt. Add proper column decorators, constraints, and indexes.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create ExecutionLog Entity with Relationships",
            "description": "Implement ExecutionLog entity with all fields and ManyToOne relationship to CronJob",
            "dependencies": [
              "2.2"
            ],
            "details": "Create database/entities/execution-log.entity.ts with fields: id (UUID), jobId (string), job (ManyToOne to CronJob), executedAt (Date), status (enum success|error), responseCode (number), responseTime (number), responseBody (text), errorMessage (nullable string), triggeredManually (boolean). Set up proper foreign key relationship and cascade options.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Set Up Database Directory and Entity Registration",
            "description": "Create database entities directory structure and register entities with TypeORM",
            "dependencies": [
              "2.3"
            ],
            "details": "Create database/entities/index.ts barrel file to export all entities. Update app.module.ts to import and register CronJob and ExecutionLog entities. Ensure proper entity scanning and autoload configuration. Create data directory with proper permissions for SQLite file.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test Database Connection and Entity Relationships",
            "description": "Verify database connection, entity creation, and test basic CRUD operations with relationships",
            "dependencies": [
              "2.4"
            ],
            "details": "Create basic test to verify database connection on app startup. Test entity creation in SQLite file. Implement basic CRUD operations using TypeORM repository methods for both entities. Verify ManyToOne relationship between ExecutionLog and CronJob works correctly. Test JSON field handling for headers.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Schedule Parser Service",
        "description": "Create service to parse and validate both repeat format (5s, 1m, 1h) and traditional crontab expressions",
        "details": "Create src/services/schedule-parser.service.ts with methods: parseRepeatInterval(schedule: string) -> milliseconds, parseCronExpression(schedule: string) -> validation, validateSchedule(schedule: string, type: 'cron' | 'repeat') -> boolean. Support repeat format regex: /^(\\d+)([smh])$/ for seconds, minutes, hours. Use node-cron or similar library for crontab validation. Handle edge cases like '0s' (invalid), maximum intervals (24h), minimum intervals (1s). Return standardized schedule objects with nextExecutionTime calculation.",
        "testStrategy": "Unit tests for various schedule formats: '30s', '5m', '2h', '*/30 * * * * *', '0 0 * * * *'. Test invalid formats return false, valid formats return correct milliseconds/cron objects. Verify edge cases and boundary conditions.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Repeat Interval Parser",
            "description": "Create logic to parse repeat format strings (5s, 1m, 1h) and convert to milliseconds",
            "dependencies": [],
            "details": "Implement parseRepeatInterval(schedule: string) method with regex /^(\\d+)([smh])$/ to extract number and unit. Convert seconds (*1000), minutes (*60000), hours (*3600000) to milliseconds. Validate minimum 1s and maximum 24h limits. Handle edge cases like '0s' (invalid), non-numeric values, and unsupported units.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Cron Expression Validation",
            "description": "Create cron expression validation using node-cron library",
            "dependencies": [],
            "details": "Install and integrate node-cron library. Implement parseCronExpression(schedule: string) method to validate traditional crontab expressions. Return validation result with parsed cron object. Handle various cron formats including seconds field support. Provide clear error messages for invalid expressions.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Schedule Validation Service",
            "description": "Build unified validation service with comprehensive edge case handling",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Implement validateSchedule(schedule: string, type: 'cron' | 'repeat') method that routes to appropriate parser. Create comprehensive validation logic for edge cases: empty strings, null values, malformed formats. Return boolean validation results with descriptive error messages. Add input sanitization and type checking.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Next Execution Time Calculator",
            "description": "Create functionality to calculate next execution time for both schedule types",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Implement calculateNextExecution(schedule: string, type: 'cron' | 'repeat') method. For repeat intervals, add milliseconds to current time. For cron expressions, use node-cron to calculate next valid execution time. Return standardized schedule objects with nextExecutionTime field. Handle timezone considerations and daylight saving time transitions.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Create CronJob CRUD Controller and DTOs",
        "description": "Implement REST API endpoints for cron job management with proper validation and DTOs",
        "details": "Create src/controllers/cronjob.controller.ts with endpoints: GET /api/jobs (list all), GET /api/jobs/:id (get one), POST /api/jobs (create), PUT /api/jobs/:id (update), DELETE /api/jobs/:id (delete). Create src/dto/create-cronjob.dto.ts and update-cronjob.dto.ts with class-validator decorators. Validate schedule format based on scheduleType, URL format, HTTP method enum, headers as key-value pairs. Implement src/services/cronjob.service.ts with TypeORM repository injection. Add proper error handling with HTTP exceptions. Use @ApiTags and @ApiOperation for Swagger documentation.",
        "testStrategy": "Unit tests for service methods using in-memory database. Integration tests for all endpoints using supertest. Test validation errors for invalid data, successful CRUD operations, proper HTTP status codes, and error responses.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DTO classes with validation decorators",
            "description": "Implement CreateCronJobDto and UpdateCronJobDto with class-validator decorators for input validation",
            "dependencies": [],
            "details": "Create src/dto/create-cronjob.dto.ts and src/dto/update-cronjob.dto.ts with proper validation decorators. Include validation for name (@IsString, @IsNotEmpty), description (@IsOptional, @IsString), url (@IsUrl), method (@IsEnum for HttpMethod), scheduleType (@IsEnum), schedule (@IsString with custom validation), headers (@IsOptional, @ValidateNested), and isActive (@IsBoolean, @IsOptional). Add custom validator for cron expression format validation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement CronJob service layer with TypeORM",
            "description": "Create service class with TypeORM repository injection for database operations",
            "dependencies": [
              "4.1"
            ],
            "details": "Create src/services/cronjob.service.ts with @Injectable decorator. Inject CronJob repository using @InjectRepository. Implement methods: findAll(), findOne(id), create(createDto), update(id, updateDto), remove(id). Add proper error handling for not found cases. Include validation for schedule format based on scheduleType. Return appropriate DTOs and handle database exceptions with meaningful error messages.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create GET endpoints for job retrieval",
            "description": "Implement GET /api/jobs and GET /api/jobs/:id endpoints with proper response formatting",
            "dependencies": [
              "4.2"
            ],
            "details": "Create src/controllers/cronjob.controller.ts with @Controller('api/jobs'). Implement GET / endpoint to return all jobs with pagination support. Implement GET /:id endpoint with UUID validation using @Param and ValidationPipe. Add proper HTTP status codes, transform responses using class-transformer. Include error handling for not found cases with @NotFoundException. Add @ApiTags('CronJobs') and @ApiOperation decorators for Swagger documentation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create POST and PUT endpoints for job management",
            "description": "Implement POST /api/jobs and PUT /api/jobs/:id endpoints with validation",
            "dependencies": [
              "4.3"
            ],
            "details": "Add POST / endpoint using @Body with CreateCronJobDto validation. Implement PUT /:id endpoint with @Param id validation and @Body UpdateCronJobDto. Use ValidationPipe for automatic DTO validation. Return created/updated job with 201/200 status codes. Handle validation errors with @BadRequestException. Add proper Swagger decorators @ApiBody, @ApiResponse for documentation including example payloads.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement DELETE endpoint and error handling",
            "description": "Create DELETE /api/jobs/:id endpoint with comprehensive error handling",
            "dependencies": [
              "4.4"
            ],
            "details": "Implement DELETE /:id endpoint with UUID validation. Return 204 No Content on successful deletion. Add global exception filter for handling database constraint errors, validation errors, and not found cases. Implement custom HTTP exceptions with descriptive messages. Add logging for all CRUD operations using @nestjs/common Logger. Include @ApiResponse decorators for all possible HTTP status codes in Swagger documentation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Swagger documentation and validation middleware",
            "description": "Complete API documentation and configure global validation middleware",
            "dependencies": [
              "4.5"
            ],
            "details": "Add comprehensive Swagger decorators: @ApiTags, @ApiOperation, @ApiResponse, @ApiBody, @ApiParam for all endpoints. Create example DTOs for documentation. Configure global ValidationPipe in main.ts with whitelist: true, forbidNonWhitelisted: true. Add class-transformer decorators for response serialization. Test all endpoints using Swagger UI interface. Add API versioning support and rate limiting configuration.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement HTTP Client Service",
        "description": "Create service to execute HTTP requests with proper error handling, timeout, and response logging",
        "details": "Create src/services/http-client.service.ts using @nestjs/axios HttpService. Implement executeRequest(job: CronJob) -> Promise<ExecutionResult> method. Support GET and POST requests with custom headers including Authorization. Set 30-second timeout, handle network errors, parse response body (limit to 10KB). Create ExecutionResult interface with status, responseCode, responseTime, responseBody, errorMessage. Log all requests to ExecutionLog entity with full response data. Handle different content-types (JSON, text, HTML). Implement request retry logic for network failures.",
        "testStrategy": "Unit tests with mocked HTTP responses for success/error cases. Test timeout handling, large response truncation, different content types. Integration tests with real HTTP endpoints (httpbin.org) for GET/POST methods. Verify proper logging to database.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up HTTP client service with @nestjs/axios integration",
            "description": "Create the base HTTP client service class and configure @nestjs/axios HttpService dependency",
            "dependencies": [],
            "details": "Create src/services/http-client.service.ts with @Injectable decorator. Import and inject HttpService from @nestjs/axios. Set up basic service structure with constructor dependency injection. Configure HttpModule in app.module.ts imports. Create ExecutionResult interface with status, responseCode, responseTime, responseBody, errorMessage fields.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement request execution logic with timeout and headers",
            "description": "Create executeRequest method with proper HTTP method support, custom headers, and timeout configuration",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement executeRequest(job: CronJob) -> Promise<ExecutionResult> method. Support GET and POST requests using HttpService. Add custom headers including Authorization from job configuration. Set 30-second timeout using axios timeout option. Extract URL, method, headers, and body from CronJob entity. Add request timing measurement for responseTime field.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Handle response processing and body size limiting",
            "description": "Process HTTP responses with content-type handling and implement 10KB response body limit",
            "dependencies": [
              "5.2"
            ],
            "details": "Parse response body based on content-type (JSON, text, HTML). Implement 10KB response body size limit with truncation. Handle different response formats and ensure proper error handling for malformed JSON. Extract status code and response headers. Convert response data to string format for storage with size validation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate database logging with ExecutionLog entity",
            "description": "Save all HTTP request results to ExecutionLog entity with complete response data",
            "dependencies": [
              "5.3"
            ],
            "details": "Inject ExecutionLog repository using @InjectRepository decorator. Create log entries with job ID, request details, response data, execution time, and status. Handle database save errors gracefully. Log both successful and failed requests with appropriate status values. Include full request/response cycle data for debugging purposes.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement retry logic for network failures",
            "description": "Add automatic retry mechanism for failed HTTP requests with exponential backoff",
            "dependencies": [
              "5.4"
            ],
            "details": "Implement retry logic for network failures (timeout, connection errors, 5xx responses). Use exponential backoff strategy with maximum 3 retry attempts. Distinguish between retryable errors (network issues) and non-retryable errors (4xx client errors). Log each retry attempt with failure reason. Update ExecutionResult to include retry count and final failure reason if all retries exhausted.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Build Core Scheduler Service",
        "description": "Implement scheduler service using @nestjs/schedule to manage job execution with both interval and cron scheduling",
        "details": "Create src/services/scheduler.service.ts using @nestjs/schedule SchedulerRegistry. Implement dynamic job registration: addIntervalJob(job: CronJob), addCronJob(job: CronJob), removeJob(jobId: string). Use SchedulerRegistry.addInterval() for repeat schedules, SchedulerRegistry.addCronJob() for cron expressions. Load all active jobs on service initialization. Handle job updates by removing old and adding new schedules. Implement job execution wrapper that calls HttpClientService and logs results. Ensure jobs persist across application restarts. Add job status tracking (running, idle, error).",
        "testStrategy": "Unit tests for job registration/removal, schedule parsing integration. Test that jobs execute at correct intervals using test timers. Verify job persistence across service restarts. Integration tests with database to ensure execution logs are created.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up SchedulerRegistry service configuration",
            "description": "Configure @nestjs/schedule module and initialize SchedulerRegistry in the scheduler service",
            "dependencies": [],
            "details": "Import ScheduleModule in app.module.ts, inject SchedulerRegistry into scheduler.service.ts, set up basic service structure with proper NestJS decorators and dependency injection",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement dynamic job registration methods",
            "description": "Create methods for adding and removing interval and cron jobs dynamically",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement addIntervalJob(), addCronJob(), and removeJob() methods using SchedulerRegistry.addInterval() and SchedulerRegistry.addCronJob(). Handle job ID management and validation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement job persistence and startup loading",
            "description": "Load all active jobs from database on service initialization and ensure persistence across restarts",
            "dependencies": [
              "6.2"
            ],
            "details": "Create onModuleInit() method to load active CronJob entities from database and register them with scheduler. Implement job restoration logic to maintain schedules across application restarts",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create job execution wrapper with HTTP calls and logging",
            "description": "Implement job execution wrapper that calls HttpClientService and logs execution results",
            "dependencies": [
              "6.2"
            ],
            "details": "Create executeJob() wrapper method that calls HttpClientService.executeRequest(), handles execution results, and creates ExecutionLog entries in database with proper error handling",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement job status tracking system",
            "description": "Add job status tracking to monitor running, idle, and error states",
            "dependencies": [
              "6.4"
            ],
            "details": "Create job status enum (running, idle, error), implement status tracking in job execution wrapper, update job status in database, and provide methods to query job status",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement job lifecycle management",
            "description": "Create methods to handle job updates, removal, and schedule modifications",
            "dependencies": [
              "6.3",
              "6.5"
            ],
            "details": "Implement updateJob() method that removes old schedule and adds new one, handle job lifecycle events, ensure proper cleanup of resources, and maintain job registry consistency",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Create Manual Job Execution Controller",
        "description": "Implement endpoint for immediate job execution with manual trigger logging",
        "details": "Create src/controllers/job-execution.controller.ts with POST /api/jobs/:id/trigger endpoint. Inject HttpClientService to execute job immediately bypassing scheduler. Mark execution log with triggeredManually: true flag. Return execution result in real-time to client. Add validation to ensure job exists and is active. Implement proper error handling for job not found, inactive jobs, execution failures. Add rate limiting to prevent abuse (max 1 trigger per job per 10 seconds). Use @ApiOperation for Swagger documentation with request/response examples.",
        "testStrategy": "Unit tests for manual execution logic, validation, rate limiting. Integration tests with real job execution and database logging. Test error cases: non-existent job, inactive job, HTTP failures. Verify manual execution flag is set in logs.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement manual trigger endpoint",
            "description": "Create POST /api/jobs/:id/trigger endpoint in job-execution.controller.ts with proper routing and Swagger documentation",
            "dependencies": [],
            "details": "Create src/controllers/job-execution.controller.ts with @Controller('api/jobs') decorator. Implement POST /:id/trigger endpoint with @Param('id') validation. Add @ApiOperation decorator with request/response examples for Swagger documentation. Set up proper HTTP status codes and response DTOs.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement job validation and execution logic",
            "description": "Add job existence validation, active status check, and HTTP client integration for immediate execution",
            "dependencies": [
              "7.1"
            ],
            "details": "Inject CronJobService and HttpClientService into controller. Validate job exists and is active before execution. Call HttpClientService.executeRequest() to bypass scheduler and execute immediately. Mark execution log with triggeredManually: true flag. Return execution result in real-time to client with proper error handling for job not found and inactive jobs.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add rate limiting and error handling",
            "description": "Implement rate limiting protection and comprehensive error handling for manual job execution",
            "dependencies": [
              "7.2"
            ],
            "details": "Add rate limiting mechanism (max 1 trigger per job per 10 seconds) using in-memory store or Redis. Implement proper error handling for job not found (404), inactive jobs (400), execution failures (500). Add request logging and audit trail. Create custom exceptions with meaningful error messages and proper HTTP status codes.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Execution Logs Controller and Cleanup Service",
        "description": "Create API endpoints for viewing execution logs and automated cleanup service for 3-day retention",
        "details": "Create src/controllers/logs.controller.ts with GET /api/jobs/:id/logs endpoint with pagination, filtering by status and date range. Implement src/services/log-cleanup.service.ts with @Cron decorator for daily cleanup at midnight. Delete logs older than 3 days using TypeORM delete query with date comparison. Add GET /api/logs/stats endpoint for success/failure counts, average response times. Implement log search functionality by job name, status, response content. Add response body truncation in API responses (show first 500 chars with expand option).",
        "testStrategy": "Unit tests for log queries, pagination, filtering, cleanup logic. Test cleanup service removes only logs older than 3 days. Integration tests for log API endpoints with sample data. Verify performance with large log datasets.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create logs controller with job-specific log retrieval endpoint",
            "description": "Implement GET /api/jobs/:id/logs endpoint with pagination, filtering by status and date range",
            "dependencies": [],
            "details": "Create src/controllers/logs.controller.ts with LogsController class. Implement GET /api/jobs/:id/logs endpoint that accepts query parameters for pagination (page, limit), status filtering (success, error), and date range filtering (startDate, endDate). Use TypeORM repository to query ExecutionLog entity with proper relations to CronJob. Return paginated response with total count, current page, and log entries.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement log statistics and search endpoints",
            "description": "Create GET /api/logs/stats endpoint for metrics and search functionality by job name, status, and content",
            "dependencies": [
              "8.1"
            ],
            "details": "Add GET /api/logs/stats endpoint to return success/failure counts, average response times, and execution frequency metrics. Implement log search functionality with query parameters for job name, execution status, and response content search. Use TypeORM query builder for complex filtering and aggregation queries. Return structured statistics data and search results with proper typing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement response body truncation and expansion",
            "description": "Add response body truncation in API responses with option to view full content",
            "dependencies": [
              "8.1"
            ],
            "details": "Modify log retrieval endpoints to truncate response body to first 500 characters by default. Add query parameter 'expand=true' to return full response body when requested. Create utility function to handle truncation logic and add '...' indicator when content is truncated. Ensure truncation preserves valid JSON structure where possible.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create automated log cleanup service",
            "description": "Implement scheduled service to automatically delete logs older than 3 days",
            "dependencies": [],
            "details": "Create src/services/log-cleanup.service.ts with @Cron('0 0 * * *') decorator for daily execution at midnight. Implement cleanup logic using TypeORM delete query with date comparison to remove ExecutionLog entries older than 3 days. Add proper error handling and logging for cleanup operations. Include configuration option for retention period.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add DTOs and validation for log endpoints",
            "description": "Create data transfer objects and validation for all log-related API endpoints",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "Create DTOs for log query parameters, pagination responses, and statistics responses. Implement validation decorators for date ranges, pagination limits, and search parameters. Add Swagger decorations for API documentation. Create response DTOs that include proper typing for log entries, statistics data, and paginated responses with metadata.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Angular Frontend Application",
        "description": "Create Angular SPA with job management interface, execution monitoring, and responsive design",
        "details": "Generate Angular 17+ application in frontend/ directory. Create components: JobListComponent (displays all jobs with status indicators), JobFormComponent (create/edit jobs with schedule type toggle), JobDetailsComponent (view job with execution history), LogViewerComponent (expandable response bodies). Implement services: JobService (HTTP client for API calls), ScheduleValidatorService (client-side validation). Use Angular Material or Bootstrap for UI components. Implement reactive forms with validation for job creation/editing. Add real-time status updates using polling or WebSocket. Make responsive design for mobile viewing. Build as static files to serve from NestJS.",
        "testStrategy": "Unit tests for components and services using Angular testing utilities. End-to-end tests using Protractor or Cypress for complete user flows. Test form validation, API integration, responsive design on different screen sizes.",
        "priority": "high",
        "dependencies": [
          4,
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Angular project and routing setup",
            "description": "Create Angular 17+ project in frontend/ directory with routing configuration",
            "dependencies": [],
            "details": "Use Angular CLI to generate new project with routing enabled. Configure app-routing.module.ts with routes for job list, job form, and job details. Set up base HTML layout with navigation and router outlet. Install Angular Material or Bootstrap for UI framework.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create JobListComponent with status indicators",
            "description": "Build main job listing component displaying all jobs with visual status indicators",
            "dependencies": [
              "9.1"
            ],
            "details": "Generate JobListComponent with table/card layout showing job name, schedule, next run, and status. Implement color-coded status indicators (running, success, failed, disabled). Add sorting and filtering capabilities. Include action buttons for edit, delete, and manual trigger.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement JobFormComponent with reactive forms",
            "description": "Create job creation and editing form with validation and schedule type toggle",
            "dependencies": [
              "9.1"
            ],
            "details": "Build reactive form with FormBuilder for job creation/editing. Include fields: name, URL, HTTP method, headers, schedule type toggle (cron/repeat), schedule input with dynamic validation. Implement client-side validation matching backend DTOs. Add schedule format hints and examples.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build JobDetailsComponent with execution history",
            "description": "Create detailed job view showing configuration and execution history",
            "dependencies": [
              "9.1"
            ],
            "details": "Generate component displaying full job details including configuration, next execution time, and paginated execution history table. Show execution timestamps, status, response codes, and duration. Include expandable rows for response body preview.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create LogViewerComponent for response bodies",
            "description": "Build expandable log viewer component for job execution response details",
            "dependencies": [
              "9.4"
            ],
            "details": "Create reusable component for displaying HTTP response bodies with syntax highlighting for JSON/XML. Implement expandable/collapsible interface, copy-to-clipboard functionality, and proper formatting for different content types. Handle large responses with truncation and full view options.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement HTTP services for API integration",
            "description": "Create Angular services for job management and schedule validation",
            "dependencies": [
              "9.1"
            ],
            "details": "Build JobService with HTTP client methods for CRUD operations, manual job triggering, and fetching execution logs. Create ScheduleValidatorService for client-side schedule format validation. Implement error handling, loading states, and response typing. Add polling service for real-time status updates.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement responsive design and mobile optimization",
            "description": "Make application responsive for mobile devices with optimized layouts",
            "dependencies": [
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Implement responsive design using CSS Grid/Flexbox and Angular Flex Layout. Create mobile-friendly navigation with hamburger menu. Optimize table layouts for small screens with horizontal scrolling or card layouts. Ensure touch-friendly buttons and proper viewport configuration.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Configure build integration with NestJS serving",
            "description": "Set up Angular build process to generate static files served by NestJS",
            "dependencies": [
              "9.6",
              "9.7"
            ],
            "details": "Configure Angular build output to NestJS public/static directory. Set up NestJS to serve Angular static files and handle client-side routing with fallback. Configure build scripts in package.json for development and production. Set up environment-specific API base URLs and build optimization.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Configure Docker Container and Production Build",
        "description": "Create multi-stage Dockerfile with production-ready configuration and deployment setup",
        "details": "Create Dockerfile with multi-stage build: Stage 1 - Node.js build environment, install dependencies, build Angular frontend and NestJS backend. Stage 2 - Alpine Linux runtime, copy built artifacts, expose port 4000. Configure NestJS to serve Angular static files from dist/. Set up environment variables: PORT, DB_PATH, NODE_ENV. Create docker-compose.yml example with volume mounts for data persistence. Add .dockerignore file. Configure production logging, health checks using @nestjs/terminus. Set up graceful shutdown handling. Add README.md with deployment instructions and API documentation links.",
        "testStrategy": "Build Docker image and test container startup, verify all endpoints work in container. Test volume persistence by restarting container. Load testing with multiple concurrent jobs. Verify health checks and graceful shutdown work correctly.",
        "priority": "high",
        "dependencies": [
          1,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create multi-stage Dockerfile with build and runtime stages",
            "description": "Implement Dockerfile with Stage 1 (Node.js build environment) and Stage 2 (Alpine Linux runtime)",
            "dependencies": [],
            "details": "Stage 1: Use node:18-alpine as build stage, set WORKDIR, copy package files, run npm install, copy source code, build Angular frontend with ng build --prod, build NestJS backend with npm run build. Stage 2: Use node:18-alpine as runtime, copy built artifacts from stage 1, install only production dependencies, set proper user permissions, expose port 4000.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure production build settings and static file serving",
            "description": "Set up NestJS to serve Angular static files and optimize production builds",
            "dependencies": [
              "10.1"
            ],
            "details": "Configure NestJS main.ts to serve static files from dist/ directory using express.static middleware. Update Angular build configuration for production optimization. Configure NestJS production settings including CORS, compression, and security headers. Set up proper asset paths and routing fallback for SPA.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set up environment variables and Docker volume configuration",
            "description": "Configure environment variables, docker-compose.yml, and .dockerignore files",
            "dependencies": [
              "10.1"
            ],
            "details": "Create .env.example with PORT, DB_PATH, NODE_ENV variables. Create docker-compose.yml with volume mounts for data persistence, environment variable configuration, and port mapping. Add .dockerignore file excluding node_modules, .git, dist, logs, and development files. Configure volume mount for SQLite database file persistence.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement health checks and graceful shutdown handling",
            "description": "Add @nestjs/terminus health checks and proper application shutdown procedures",
            "dependencies": [
              "10.2"
            ],
            "details": "Install and configure @nestjs/terminus for health checks. Create /health endpoint checking database connection, disk space, and memory usage. Implement graceful shutdown handling with SIGTERM/SIGINT listeners. Add proper cleanup for database connections, scheduled tasks, and ongoing HTTP requests. Configure Docker health check in Dockerfile.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create deployment documentation and production logging configuration",
            "description": "Add README.md deployment instructions and configure production logging",
            "dependencies": [
              "10.3",
              "10.4"
            ],
            "details": "Create comprehensive README.md with Docker build instructions, environment variable documentation, deployment examples, and API documentation links. Configure production logging with proper log levels, structured JSON output, log rotation, and error handling. Add monitoring and troubleshooting guides for common deployment scenarios.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-27T05:24:49.605Z",
      "updated": "2025-08-27T10:15:44.553Z",
      "description": "Tasks for master context"
    }
  }
}