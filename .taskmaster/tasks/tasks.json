{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Add MySQL Dependencies and Database Configuration Service",
        "description": "Install mysql2 driver and create a configurable database service to support both SQLite and MySQL connections",
        "details": "1. Install mysql2 package via npm\n2. Create DatabaseConfigService with environment-based switching\n3. Update app.module.ts to use dynamic database configuration\n4. Add MySQL environment variables to .env.example\n5. Implement connection pooling and timeout configurations\n6. Create database factory that returns appropriate TypeORM configuration based on DB_TYPE env var",
        "testStrategy": "Unit tests for DatabaseConfigService with both SQLite and MySQL configurations. Integration tests to verify successful connections to both database types.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install mysql2 Package and Update Dependencies",
            "description": "Install the mysql2 driver package and update package.json with the MySQL database dependency",
            "dependencies": [],
            "details": "Run `npm install mysql2` to add MySQL database driver. Verify the package is added to dependencies in package.json. The mysql2 package will provide the MySQL driver for TypeORM to connect to MySQL databases.",
            "status": "done",
            "testStrategy": "Verify mysql2 package is listed in package.json dependencies. Test that the package can be imported without errors."
          },
          {
            "id": 2,
            "title": "Create DatabaseConfigService with Environment-Based Database Type Switching",
            "description": "Create a new service that provides TypeORM configuration based on environment variables for both SQLite and MySQL",
            "dependencies": [
              "11.1"
            ],
            "details": "Create src/services/database-config.service.ts that exports a DatabaseConfigService class. The service should read DB_TYPE environment variable (default: 'sqlite') and return appropriate TypeORM configuration. For SQLite: use existing configuration. For MySQL: return configuration with mysql2 driver, connection pooling, and proper MySQL settings. Include connection timeout, pool size, and charset configurations.",
            "status": "done",
            "testStrategy": "Unit tests to verify correct configuration returned for both 'sqlite' and 'mysql' DB_TYPE values. Test default behavior when DB_TYPE is not set."
          },
          {
            "id": 3,
            "title": "Update app.module.ts to Use Dynamic Database Configuration",
            "description": "Modify the TypeORM configuration in app.module.ts to use the DatabaseConfigService for dynamic database selection",
            "dependencies": [
              "11.2"
            ],
            "details": "Replace the static TypeORM.forRoot() configuration in app.module.ts with TypeOrmModule.forRootAsync() that uses DatabaseConfigService. Import ConfigModule to enable environment variable access. The module should inject DatabaseConfigService and call a method to get the database configuration based on the current environment settings.",
            "status": "done",
            "testStrategy": "Integration tests to verify the module loads correctly with both SQLite and MySQL configurations. Test that the correct database type is used based on environment variables."
          },
          {
            "id": 4,
            "title": "Add MySQL Environment Variables to .env.example",
            "description": "Update the .env.example file to include all necessary MySQL connection environment variables",
            "dependencies": [],
            "details": "Add the following environment variables to .env.example: DB_TYPE (sqlite/mysql), MYSQL_HOST, MYSQL_PORT, MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_DATABASE, MYSQL_CONNECTION_TIMEOUT, MYSQL_POOL_SIZE, MYSQL_CHARSET. Include comments explaining each variable's purpose and provide example values.",
            "status": "done",
            "testStrategy": "Verify .env.example contains all required MySQL variables with appropriate default values and documentation comments."
          },
          {
            "id": 5,
            "title": "Implement Connection Pooling and Database Factory Pattern",
            "description": "Create a database factory that returns optimized TypeORM configuration with connection pooling for both database types",
            "dependencies": [
              "11.2"
            ],
            "details": "Extend DatabaseConfigService to include a factory method that returns complete TypeORM DataSource configuration. Implement connection pooling settings: for MySQL use pool size 5-20, connection timeout 60000ms, acquire timeout 60000ms. For SQLite, implement appropriate connection settings. Add retry logic and connection validation. Include proper error handling for connection failures.",
            "status": "done",
            "testStrategy": "Test connection pooling settings are applied correctly. Verify connection timeout and retry logic work as expected. Test that connections are properly managed and released."
          }
        ]
      },
      {
        "id": 12,
        "title": "Design and Create Tag Entity with Database Schema",
        "description": "Create the Tag entity with proper MySQL-compatible schema, including junction table for many-to-many relationships",
        "details": "1. Create Tag entity with id(uuid), name(varchar 50), color(varchar 7), usageCount(int), createdAt, updatedAt\n2. Add unique constraint on tag name with index\n3. Create junction table cronjob_tags with composite primary key\n4. Update CronJob entity to include @ManyToMany relationship with Tag\n5. Add cascade options for tag operations\n6. Ensure MySQL compatibility with proper column types and indexes",
        "testStrategy": "Unit tests for Tag entity validation. Database schema tests to verify proper table creation, indexes, and foreign key constraints. Test cascade operations for tag deletion.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Tag Entity with UUID Primary Key and MySQL-Compatible Schema",
            "description": "Create the Tag entity class with proper TypeORM decorators for MySQL compatibility, including UUID primary key, name validation, color field, and usage tracking",
            "dependencies": [],
            "details": "Create Tag entity in src/entities/tag.entity.ts with @Entity('tags') decorator, UUID primary key using @PrimaryGeneratedColumn('uuid'), name column with @Column({ length: 50, unique: true }), color column with @Column({ length: 7, default: '#808080' }) for hex colors, usageCount column with @Column({ type: 'int', default: 0 }), and @CreateDateColumn() and @UpdateDateColumn() for timestamps. Add @Index() on name column for performance.",
            "status": "done",
            "testStrategy": "Unit tests for Tag entity validation including name length limits, color hex format validation, and UUID generation"
          },
          {
            "id": 2,
            "title": "Create Junction Table Schema for CronJob-Tag Many-to-Many Relationship",
            "description": "Define the database schema for the cronjob_tags junction table with composite primary key and proper foreign key constraints",
            "dependencies": [
              "12.1"
            ],
            "details": "Create cronjob_tags junction table using TypeORM @JoinTable decorator with explicit configuration: @JoinTable({ name: 'cronjob_tags', joinColumn: { name: 'cronjobId', referencedColumnName: 'id' }, inverseJoinColumn: { name: 'tagId', referencedColumnName: 'id' } }). Ensure composite primary key on (cronjobId, tagId) and proper foreign key constraints with CASCADE options.",
            "status": "done",
            "testStrategy": "Database schema tests to verify junction table creation, composite primary key constraints, and foreign key relationships"
          },
          {
            "id": 3,
            "title": "Update CronJob Entity with Many-to-Many Tag Relationship",
            "description": "Modify the existing CronJob entity to include the many-to-many relationship with Tag entity and proper cascade options",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "Add to CronJob entity: @ManyToMany(() => Tag, { cascade: ['insert', 'update'], onDelete: 'CASCADE' }) @JoinTable({ name: 'cronjob_tags' }) tags: Tag[]. Import Tag entity and ManyToMany, JoinTable decorators from typeorm. Update the entity imports in app.module.ts to include Tag entity.",
            "status": "done",
            "testStrategy": "Integration tests for CronJob entity with tag relationships, testing cascade operations and proper loading of associated tags"
          },
          {
            "id": 4,
            "title": "Update AppModule to Include Tag Entity in TypeORM Configuration",
            "description": "Modify app.module.ts to register the new Tag entity with TypeORM and ensure proper database synchronization",
            "dependencies": [
              "12.1"
            ],
            "details": "Update app.module.ts TypeOrmModule.forRoot configuration to include Tag in entities array: entities: [CronJob, ExecutionLog, Tag]. Import Tag entity at the top of the file. Ensure synchronize option is enabled for development to auto-create tables and relationships.",
            "status": "done",
            "testStrategy": "Integration tests to verify Tag entity is properly registered and tables are created during application startup"
          },
          {
            "id": 5,
            "title": "Create Database Indexes and Constraints for Tag Operations",
            "description": "Add appropriate database indexes and constraints to optimize tag queries and ensure data integrity",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3"
            ],
            "details": "Add @Index() decorators to Tag entity: unique index on name column for fast lookups and constraint enforcement, index on usageCount for sorting operations, and index on createdAt for chronological queries. Add validation constraints using class-validator decorators: @IsString(), @Length(1, 50) for name, @Matches(/^#[0-9A-Fa-f]{6}$/) for color hex format.",
            "status": "done",
            "testStrategy": "Database performance tests to verify index usage, constraint validation tests for tag name uniqueness and color format, and data integrity tests for cascade operations"
          }
        ]
      },
      {
        "id": 13,
        "title": "Update Existing Entities for MySQL Compatibility",
        "description": "Modify CronJob and ExecutionLog entities to ensure full MySQL compatibility with optimized column types",
        "details": "1. Convert UUID fields from TEXT to proper MySQL UUID handling\n2. Update datetime fields to use MySQL DATETIME type\n3. Convert TEXT fields to appropriate VARCHAR/TEXT/MEDIUMTEXT based on content size\n4. Update enum handling for MySQL compatibility\n5. Optimize indexes for MySQL query planner\n6. Add proper character set (utf8mb4) and collation settings\n7. Test all entity relationships work correctly with MySQL",
        "testStrategy": "Database compatibility tests for all entity operations. Verify data type conversions work correctly. Test enum handling and datetime operations with MySQL.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update CronJob Entity UUID and Enum Handling for MySQL",
            "description": "Modify the CronJob entity to properly handle UUID fields and enums for MySQL compatibility",
            "dependencies": [],
            "details": "Update @PrimaryGeneratedColumn('uuid') to use proper MySQL UUID handling with @Column({ type: 'varchar', length: 36 }). Convert enum columns (method, scheduleType, executionMode) from 'text' type to proper MySQL enum syntax with @Column({ type: 'enum', enum: EnumName }). Ensure all UUID fields use consistent VARCHAR(36) typing for MySQL compatibility.",
            "status": "done",
            "testStrategy": "Test UUID generation and retrieval. Verify enum values are properly constrained and stored. Test entity creation and updates with MySQL database."
          },
          {
            "id": 2,
            "title": "Optimize CronJob Text Fields for MySQL Storage",
            "description": "Convert TEXT columns to appropriate VARCHAR/TEXT/MEDIUMTEXT based on expected content size for better MySQL performance",
            "dependencies": [
              "13.1"
            ],
            "details": "Analyze content size requirements: Convert 'url' from TEXT to VARCHAR(2048), 'headers' to TEXT, 'body' to MEDIUMTEXT for large payloads, 'description' to VARCHAR(1000). Update column definitions with appropriate length constraints. Add proper character set (utf8mb4) and collation (utf8mb4_unicode_ci) for international character support.",
            "status": "done",
            "testStrategy": "Test storage and retrieval of various content sizes. Verify character encoding works with special characters. Test performance impact of different column types."
          },
          {
            "id": 3,
            "title": "Update ExecutionLog Entity for MySQL Compatibility",
            "description": "Modify the ExecutionLog entity to use proper MySQL data types and optimize storage",
            "dependencies": [
              "13.1"
            ],
            "details": "Convert @PrimaryGeneratedColumn('uuid') to VARCHAR(36). Update 'jobId' from 'uuid' type to 'varchar' length 36. Change 'status' enum from 'text' type to proper MySQL enum. Convert 'responseBody' and 'errorMessage' from TEXT to MEDIUMTEXT for larger content. Ensure datetime columns use proper MySQL DATETIME type with timezone handling.",
            "status": "done",
            "testStrategy": "Test ExecutionLog creation with various response sizes. Verify foreign key relationships work correctly. Test enum constraint validation and datetime operations."
          },
          {
            "id": 4,
            "title": "Optimize MySQL Indexes and Performance",
            "description": "Review and optimize existing indexes for MySQL query planner and add composite indexes where beneficial",
            "dependencies": [
              "13.2",
              "13.3"
            ],
            "details": "Review existing @Index annotations and optimize for MySQL. Add composite indexes for common query patterns like @Index(['isActive', 'scheduleType']), @Index(['jobId', 'executedAt']) for ExecutionLog. Consider adding indexes on frequently filtered columns. Ensure index names are MySQL-compatible and don't exceed length limits. Add database-specific performance optimizations.",
            "status": "done",
            "testStrategy": "Run query performance tests before and after index optimization. Use MySQL EXPLAIN to verify query plans. Test index usage with realistic data volumes."
          },
          {
            "id": 5,
            "title": "Add MySQL Character Set Configuration and Entity Validation",
            "description": "Configure proper character sets and collations, and validate all entity relationships work correctly with MySQL",
            "dependencies": [
              "13.1",
              "13.2",
              "13.3",
              "13.4"
            ],
            "details": "Add @Entity table options with charset and collation: @Entity('cronjobs', { charset: 'utf8mb4', collation: 'utf8mb4_unicode_ci' }). Test all OneToMany and ManyToOne relationships work correctly with new MySQL column types. Verify CASCADE operations function properly. Add validation decorators where appropriate. Test data migration compatibility between old and new schema.",
            "status": "done",
            "testStrategy": "Test complete entity lifecycle (CRUD operations) with MySQL. Verify relationship cascading works correctly. Test international character storage and retrieval. Validate schema changes don't break existing functionality."
          }
        ]
      },
      {
        "id": 14,
        "title": "Create Tag Repository and Service Layer",
        "description": "Implement comprehensive Tag management service with CRUD operations, usage tracking, and efficient querying",
        "details": "1. Create TagRepository extending TypeORM Repository\n2. Implement TagService with methods: create, findAll, findById, update, delete, searchByName\n3. Add usage count tracking and automatic increment/decrement\n4. Implement tag search with autocomplete functionality\n5. Add bulk operations for tag management\n6. Create efficient queries for tag filtering with job counts\n7. Add validation for tag name uniqueness and color format",
        "testStrategy": "Unit tests for all TagService methods. Test usage count tracking accuracy. Performance tests for tag search and filtering operations. Test bulk operations and transaction handling.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create TypeORM Migration Scripts",
        "description": "Generate comprehensive TypeORM migrations for database schema changes and data structure updates",
        "details": "1. Generate initial migration for MySQL schema creation\n2. Create migration for Tag entity and junction table\n3. Create migration for CronJob entity updates (add tag relationships)\n4. Generate migration for ExecutionLog entity MySQL compatibility\n5. Add rollback migrations for all changes\n6. Create migration validation scripts to verify schema integrity\n7. Add migration scripts to package.json for easy execution",
        "testStrategy": "Test all migrations run successfully on clean MySQL database. Test rollback functionality works correctly. Verify schema matches expected structure after migration.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate Initial MySQL Schema Creation Migration",
            "description": "Create the primary migration file to set up MySQL database schema with optimized structure for CronJob and ExecutionLog entities",
            "dependencies": [],
            "details": "Use TypeORM CLI to generate migration with 'typeorm migration:generate InitialMySQLSchema'. Create migration files in src/migrations/ directory. Include proper MySQL data types: VARCHAR(36) for UUIDs, ENUM for status fields, DATETIME for timestamps, MEDIUMTEXT for large content. Add proper indexes, constraints, and foreign key relationships. Configure utf8mb4 charset and unicode_ci collation for all tables. Include connection pooling and performance optimizations in migration configuration.",
            "status": "done",
            "testStrategy": "Test migration runs successfully on clean MySQL database. Verify all tables, indexes, and constraints are created correctly. Test rollback functionality. Validate schema matches entity definitions."
          },
          {
            "id": 2,
            "title": "Create Tag Entity and Junction Table Migration",
            "description": "Generate migration for Tag entity and cronjob_tags junction table to support many-to-many relationships",
            "dependencies": [
              "15.1"
            ],
            "details": "Create migration file for Tag table with id (VARCHAR(36)), name (VARCHAR(50) UNIQUE), color (VARCHAR(7)), usageCount (INT), createdAt/updatedAt (DATETIME). Add unique index on name field. Create cronjob_tags junction table with composite primary key (cronjobId, tagId) and foreign key constraints. Include proper CASCADE delete behavior. Configure proper MySQL storage engine (InnoDB) for transaction support. Add validation constraints for color format (hex) and name length.",
            "status": "done",
            "testStrategy": "Test tag table creation and junction table relationships. Verify unique constraints work correctly. Test cascade operations and foreign key constraints. Validate many-to-many associations function properly."
          },
          {
            "id": 3,
            "title": "Create CronJob Tag Relationships Migration",
            "description": "Generate migration to add tag relationship columns and update existing CronJob entity structure for MySQL compatibility",
            "dependencies": [
              "15.2"
            ],
            "details": "Create migration to modify CronJob table: convert UUID fields to VARCHAR(36), update enum columns from TEXT to proper MySQL ENUM types (method, scheduleType, executionMode), optimize TEXT fields to VARCHAR/MEDIUMTEXT based on content size. Add any missing indexes for tag relationships. Update foreign key constraints for execution logs relationship. Ensure all column types are MySQL-optimized for performance.",
            "status": "done",
            "testStrategy": "Test CronJob entity updates with tag relationships. Verify enum handling works correctly in MySQL. Test data integrity during column type conversions. Validate performance improvements with new column types."
          },
          {
            "id": 4,
            "title": "Create ExecutionLog MySQL Compatibility Migration",
            "description": "Generate migration to update ExecutionLog entity for full MySQL compatibility and performance optimization",
            "dependencies": [
              "15.3"
            ],
            "details": "Create migration to update ExecutionLog table: convert id and jobId to VARCHAR(36), update status enum to proper MySQL ENUM type, change responseBody and errorMessage to MEDIUMTEXT for larger content storage, optimize datetime columns with proper MySQL DATETIME type. Add composite indexes for common query patterns like (jobId, executedAt) and (status, executedAt). Ensure foreign key relationships with CronJob table work correctly.",
            "status": "done",
            "testStrategy": "Test ExecutionLog entity operations with new MySQL schema. Verify large response body storage works correctly. Test query performance with new composite indexes. Validate foreign key relationships and cascade operations."
          },
          {
            "id": 5,
            "title": "Add Migration Scripts and Validation Tools to Package.json",
            "description": "Create npm scripts for migration management and add validation tools to verify schema integrity after migrations",
            "dependencies": [
              "15.1",
              "15.2",
              "15.3",
              "15.4"
            ],
            "details": "Add migration scripts to package.json: 'migration:run', 'migration:revert', 'migration:generate', 'migration:show'. Create validation script 'migration:validate' that checks schema integrity, verifies all indexes exist, validates foreign key constraints, and compares actual schema against entity definitions. Add 'migration:reset' for development cleanup. Include environment-specific migration scripts for different deployment stages. Create pre-migration backup script and post-migration validation workflow.",
            "status": "done",
            "testStrategy": "Test all migration scripts execute correctly. Verify validation tool catches schema inconsistencies. Test rollback scenarios work properly. Validate migration scripts work across different environments (dev/prod)."
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Tag API Endpoints and DTOs",
        "description": "Create REST API endpoints for tag management with proper validation, filtering, and search capabilities",
        "details": "1. Create TagController with endpoints: GET /tags, POST /tags, PUT /tags/:id, DELETE /tags/:id\n2. Create DTOs: CreateTagDto, UpdateTagDto, TagResponseDto\n3. Implement tag search endpoint: GET /tags/search?q=query\n4. Add tag attachment endpoints: POST /jobs/:id/tags, DELETE /jobs/:id/tags/:tagId\n5. Update job endpoints to support tag filtering: GET /jobs?tags=tag1,tag2&tagsMode=AND|OR\n6. Add proper validation, error handling, and Swagger documentation\n7. Implement permission checks and input sanitization",
        "testStrategy": "API integration tests for all tag endpoints. Test tag filtering functionality with various combinations. Validate error handling for invalid inputs. Test API documentation accuracy.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Data Migration and Validation Tools",
        "description": "Build tools for exporting SQLite data, transforming it, and importing to MySQL with comprehensive validation",
        "details": "1. Create SQLite data export service with JSON output\n2. Implement data transformation pipeline for MySQL compatibility\n3. Create batch import service for MySQL with progress tracking\n4. Build data validation tools to verify integrity post-migration\n5. Implement rollback capability for failed migrations\n6. Add logging and progress reporting for migration process\n7. Create CLI commands for migration operations\n8. Handle UUID format conversion and datetime transformations",
        "testStrategy": "Test data export produces valid JSON. Test data transformation handles all edge cases. Test import process with various data sizes. Verify validation tools catch data inconsistencies.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Update Frontend UI Components for Tag Management",
        "description": "Implement Angular components for tag creation, management, filtering, and visual display throughout the application",
        "details": "1. Create TagChipComponent for displaying tags with color coding\n2. Create TagInputComponent with autocomplete functionality\n3. Create TagFilterComponent for job list filtering (single/multiple selection)\n4. Create TagManagementComponent for admin tag operations\n5. Update JobFormComponent to include tag selection\n6. Update JobListComponent to display tags and support filtering\n7. Add tag color picker and visual indicators\n8. Implement responsive design for mobile compatibility",
        "testStrategy": "Unit tests for all Angular components. E2E tests for tag workflows. Test autocomplete performance and accuracy. Test responsive design on various screen sizes.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Comprehensive Test Suite for Migration and Tag System",
        "description": "Create extensive test coverage for all migration processes, tag functionality, and database compatibility",
        "details": "1. Create unit tests for all new services and repositories\n2. Build integration tests for MySQL database operations\n3. Create E2E tests for complete tag workflows\n4. Implement performance benchmarks for tag filtering with large datasets\n5. Test concurrent operation handling with MySQL\n6. Create load tests for migration process with various data sizes\n7. Test data integrity validation tools\n8. Add tests for edge cases and error scenarios\n9. Achieve 90% code coverage requirement",
        "testStrategy": "Automated test execution in CI/CD pipeline. Performance benchmarking reports. Code coverage analysis. Load testing results validation.",
        "priority": "medium",
        "dependencies": [
          17,
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Production Deployment Strategy and Documentation",
        "description": "Create comprehensive deployment procedures, monitoring setup, and complete documentation for the migration and tag system",
        "details": "1. Create step-by-step production migration guide\n2. Implement database monitoring and health checks\n3. Create rollback procedures and emergency protocols\n4. Document all new API endpoints and tag system features\n5. Create user guide for tag management functionality\n6. Set up logging and alerting for migration process\n7. Create deployment validation checklist\n8. Document performance optimization configurations\n9. Create troubleshooting guide for common issues",
        "testStrategy": "Test deployment procedures in staging environment. Validate monitoring and alerting systems. Test rollback procedures under various failure scenarios. Review documentation completeness and accuracy.",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-27T05:24:49.605Z",
      "updated": "2025-09-03T12:38:04.494Z",
      "description": "Tasks for master context"
    }
  }
}